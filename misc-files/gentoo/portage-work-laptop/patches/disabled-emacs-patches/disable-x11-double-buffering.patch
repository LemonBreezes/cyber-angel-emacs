diff --git a/configure.ac b/configure.ac
index c91b7de322a..1cabdb66db0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -466,7 +466,7 @@ OPTION_DEFAULT_ON([m17n-flt],[don't use m17n-flt for text shaping])
 OPTION_DEFAULT_ON([toolkit-scroll-bars],[don't use Motif/Xaw3d/GTK toolkit scroll bars])
 OPTION_DEFAULT_ON([xaw3d],[don't use Xaw3d])
 OPTION_DEFAULT_ON([xim],[at runtime, default X11 XIM to off])
-OPTION_DEFAULT_ON([xdbe],[don't use X11 double buffering support])
+OPTION_DEFAULT_OFF([xdbe],[don't use X11 double buffering support])
 AC_ARG_WITH([ns],[AS_HELP_STRING([--with-ns],
 [use Nextstep (macOS Cocoa or GNUstep) windowing system.
 On by default on macOS.])],[],[with_ns=maybe])
@@ -4618,9 +4618,6 @@ if test "${HAVE_X11}" = "yes"; then
       [#include <X11/Xlib.h>
       ])
   fi
-  if test $HAVE_XDBE = yes; then
-    XDBE_LIBS=-lXext
-  fi
   if test $HAVE_XDBE = yes; then
     AC_DEFINE(HAVE_XDBE, 1, [Define to 1 if you have the Xdbe extension.])
   fi
diff --git a/src/gtkutil.c b/src/gtkutil.c
index f2018bc01f5..ad92ccef338 100644
--- a/src/gtkutil.c
+++ b/src/gtkutil.c
@@ -62,10 +62,6 @@ typedef struct pgtk_output xp_output;
 #include "emacsgtkfixed.h"
 #endif
 
-#ifdef HAVE_XDBE
-#include <X11/extensions/Xdbe.h>
-#endif
-
 #ifdef HAVE_GTK3
 #define XG_TEXT_CANCEL "Cancel"
 #define XG_TEXT_OK     "OK"
@@ -1887,7 +1883,6 @@ xg_free_frame_widgets (struct frame *f)
 
       /* x_free_frame_resources should have taken care of it */
 #ifndef HAVE_PGTK
-      eassert (!FRAME_X_DOUBLE_BUFFERED_P (f));
       g_object_unref (FRAME_X_OUTPUT (f)->im_context);
 #endif
       gtk_widget_destroy (FRAME_GTK_OUTER_WIDGET (f));
diff --git a/src/xfns.c b/src/xfns.c
index 1372809da68..dcaaaf34021 100644
--- a/src/xfns.c
+++ b/src/xfns.c
@@ -60,10 +60,6 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include "gtkutil.h"
 #endif
 
-#ifdef HAVE_XDBE
-#include <X11/extensions/Xdbe.h>
-#endif
-
 #ifdef HAVE_XINPUT2
 #include <X11/extensions/XInput2.h>
 #endif
@@ -823,50 +819,6 @@ x_set_tool_bar_position (struct frame *f,
     wrong_choice (choice, new_value);
 }
 
-#ifdef HAVE_XDBE
-static void
-x_set_inhibit_double_buffering (struct frame *f,
-                                Lisp_Object new_value,
-                                Lisp_Object old_value)
-{
-  bool want_double_buffering, was_double_buffered;
-
-  if (FRAME_X_WINDOW (f) && !EQ (new_value, old_value))
-    {
-      want_double_buffering = NILP (new_value);
-      was_double_buffered = FRAME_X_DOUBLE_BUFFERED_P (f);
-
-      block_input ();
-      if (want_double_buffering != was_double_buffered)
-	{
-	  /* Force XftDraw etc to be recreated with the new double
-	     buffered drawable.  */
-	  font_drop_xrender_surfaces (f);
-
-	  /* Scroll bars decide whether or not to use a back buffer
-	     based on the value of this frame parameter, so destroy
-	     all scroll bars.  */
-#ifndef USE_TOOLKIT_SCROLL_BARS
-	  if (FRAME_TERMINAL (f)->condemn_scroll_bars_hook)
-	    FRAME_TERMINAL (f)->condemn_scroll_bars_hook (f);
-	  if (FRAME_TERMINAL (f)->judge_scroll_bars_hook)
-	    FRAME_TERMINAL (f)->judge_scroll_bars_hook (f);
-#endif
-	}
-      if (FRAME_X_DOUBLE_BUFFERED_P (f) && !want_double_buffering)
-        tear_down_x_back_buffer (f);
-      else if (!FRAME_X_DOUBLE_BUFFERED_P (f) && want_double_buffering)
-        set_up_x_back_buffer (f);
-      if (FRAME_X_DOUBLE_BUFFERED_P (f) != was_double_buffered)
-        {
-          SET_FRAME_GARBAGED (f);
-          font_drop_xrender_surfaces (f);
-        }
-      unblock_input ();
-    }
-}
-#endif
-
 /**
  * x_set_undecorated:
  *
@@ -3612,11 +3564,6 @@ xic_set_xfontset (struct frame *f, const char *base_fontname)
 void
 x_mark_frame_dirty (struct frame *f)
 {
-#ifdef HAVE_XDBE
-  if (FRAME_X_DOUBLE_BUFFERED_P (f)
-      && !FRAME_X_NEED_BUFFER_FLIP (f))
-    FRAME_X_NEED_BUFFER_FLIP (f) = true;
-#endif
 }
 
 static void
@@ -3632,32 +3579,6 @@ set_up_x_back_buffer (struct frame *f)
     }
   unblock_input ();
 #endif
-
-#ifdef HAVE_XDBE
-  block_input ();
-  if (FRAME_X_WINDOW (f) && !FRAME_X_DOUBLE_BUFFERED_P (f))
-    {
-#ifdef USE_CAIRO
-      x_cr_destroy_frame_context (f);
-#endif
-      FRAME_X_RAW_DRAWABLE (f) = FRAME_X_WINDOW (f);
-      if (FRAME_DISPLAY_INFO (f)->supports_xdbe)
-        {
-          /* If allocating a back buffer fails, either because the
-             server ran out of memory or we don't have the right kind
-             of visual, just use single-buffered rendering.  */
-          x_catch_errors (FRAME_X_DISPLAY (f));
-          FRAME_X_RAW_DRAWABLE (f)
-	    = XdbeAllocateBackBufferName (FRAME_X_DISPLAY (f),
-					  FRAME_X_WINDOW (f),
-					  XdbeCopied);
-          if (x_had_errors_p (FRAME_X_DISPLAY (f)))
-            FRAME_X_RAW_DRAWABLE (f) = FRAME_X_WINDOW (f);
-          x_uncatch_errors_after_check ();
-        }
-    }
-  unblock_input ();
-#endif
 }
 
 void
@@ -3673,23 +3594,6 @@ tear_down_x_back_buffer (struct frame *f)
     }
   unblock_input ();
 #endif
-
-#ifdef HAVE_XDBE
-  block_input ();
-  if (FRAME_X_WINDOW (f) && FRAME_X_DOUBLE_BUFFERED_P (f))
-    {
-      if (FRAME_X_DOUBLE_BUFFERED_P (f))
-        {
-#ifdef USE_CAIRO
-	  x_cr_destroy_frame_context (f);
-#endif
-          XdbeDeallocateBackBufferName (FRAME_X_DISPLAY (f),
-                                        FRAME_X_DRAWABLE (f));
-          FRAME_X_RAW_DRAWABLE (f) = FRAME_X_WINDOW (f);
-        }
-    }
-  unblock_input ();
-#endif
 }
 
 /* Set up double buffering if the frame parameters don't prohibit
@@ -8809,11 +8713,7 @@ DEFUN ("x-double-buffered-p", Fx_double_buffered_p, Sx_double_buffered_p,
 {
   struct frame *f = decode_live_frame (frame);
 
-#ifdef HAVE_XDBE
-  return FRAME_X_DOUBLE_BUFFERED_P (f) ? Qt : Qnil;
-#else
   return Qnil;
-#endif
 }
 
 
@@ -9584,11 +9484,7 @@ frame_parm_handler x_frame_parm_handlers[] =
   x_set_alpha,
   x_set_sticky,
   x_set_tool_bar_position,
-#ifdef HAVE_XDBE
-  x_set_inhibit_double_buffering,
-#else
   NULL,
-#endif
   x_set_undecorated,
   x_set_parent_frame,
   x_set_skip_taskbar,
diff --git a/src/xftfont.c b/src/xftfont.c
index 6043ef9f94f..3eed8b613f5 100644
--- a/src/xftfont.c
+++ b/src/xftfont.c
@@ -643,24 +643,6 @@ xftfont_end_for_frame (struct frame *f)
   return 0;
 }
 
-/* When using X double buffering, the XRender surfaces we create seem
-   to become useless once the window acting as the front buffer is
-   resized for an unknown reason (X server bug?), so recreate it on
-   ConfigureNotify and in some other cases.  */
-
-#ifdef HAVE_XDBE
-static void
-xftfont_drop_xrender_surfaces (struct frame *f)
-{
-  if (FRAME_X_DOUBLE_BUFFERED_P (f))
-    {
-      block_input ();
-      xftfont_end_for_frame (f);
-      unblock_input ();
-    }
-}
-#endif
-
 static bool
 xftfont_cached_font_ok (struct frame *f, Lisp_Object font_object,
                         Lisp_Object entity)
@@ -774,9 +756,6 @@ struct font_driver const xftfont_driver =
     .filter_properties = ftfont_filter_properties,
     .cached_font_ok = xftfont_cached_font_ok,
     .combining_capability = ftfont_combining_capability,
-#ifdef HAVE_XDBE
-    .drop_xrender_surfaces = xftfont_drop_xrender_surfaces,
-#endif
   };
 #ifdef HAVE_HARFBUZZ
 struct font_driver xfthbfont_driver;
diff --git a/src/xterm.c b/src/xterm.c
index 9a31f9ea094..420ae3d44c2 100644
--- a/src/xterm.c
+++ b/src/xterm.c
@@ -581,10 +581,6 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <X11/extensions/Xfixes.h>
 #endif
 
-#ifdef HAVE_XDBE
-#include <X11/extensions/Xdbe.h>
-#endif
-
 #ifdef HAVE_XINPUT2
 #include <X11/extensions/XInput2.h>
 #endif
@@ -1095,10 +1091,6 @@ static void x_initialize (void);
 static bool x_get_current_wm_state (struct frame *, Window, int *, bool *, bool *);
 static void x_update_opaque_region (struct frame *, XEvent *);
 
-#if !defined USE_TOOLKIT_SCROLL_BARS && defined HAVE_XDBE
-static void x_scroll_bar_end_update (struct x_display_info *, struct scroll_bar *);
-#endif
-
 #ifdef HAVE_X_I18N
 static int x_filter_event (struct x_display_info *, XEvent *);
 #endif
@@ -4691,24 +4683,6 @@ x_flush (struct frame *f)
   unblock_input ();
 }
 
-#ifdef HAVE_XDBE
-static void
-x_drop_xrender_surfaces (struct frame *f)
-{
-  font_drop_xrender_surfaces (f);
-
-#ifdef HAVE_XRENDER
-  if (f && FRAME_X_DOUBLE_BUFFERED_P (f)
-      && FRAME_X_PICTURE (f) != None)
-    {
-      XRenderFreePicture (FRAME_X_DISPLAY (f),
-			  FRAME_X_PICTURE (f));
-      FRAME_X_PICTURE (f) = None;
-    }
-#endif
-}
-#endif
-
 #ifdef HAVE_XRENDER
 void
 x_xr_ensure_picture (struct frame *f)
@@ -5391,8 +5365,6 @@ void
 x_end_cr_clip (struct frame *f)
 {
   cairo_restore (FRAME_CR_CONTEXT (f));
-  if (FRAME_X_DOUBLE_BUFFERED_P (f))
-    x_mark_frame_dirty (f);
 }
 
 void
@@ -6101,9 +6073,6 @@ x_clear_window (struct frame *f)
 #else
 #ifndef USE_GTK
   if (f->alpha_background != 1.0
-#ifdef HAVE_XDBE
-      || FRAME_X_DOUBLE_BUFFERED_P (f)
-#endif
       )
 #endif
     x_clear_area (f, 0, 0, FRAME_PIXEL_WIDTH (f),
@@ -6483,31 +6452,6 @@ x_draw_window_divider (struct window *w, int x0, int x1, int y0, int y1)
    atomically publish to the user's screen graphics updates made since
    the last call to show_back_buffer.  */
 
-#ifdef HAVE_XDBE
-static void
-show_back_buffer (struct frame *f)
-{
-  block_input ();
-
-  if (FRAME_X_DOUBLE_BUFFERED_P (f))
-    {
-#ifdef USE_CAIRO
-      cairo_t *cr = FRAME_CR_CONTEXT (f);
-      if (cr)
-	cairo_surface_flush (cairo_get_target (cr));
-#endif
-      XdbeSwapInfo swap_info;
-      memset (&swap_info, 0, sizeof (swap_info));
-      swap_info.swap_window = FRAME_X_WINDOW (f);
-      swap_info.swap_action = XdbeCopied;
-      XdbeSwapBuffers (FRAME_X_DISPLAY (f), &swap_info, 1);
-    }
-  FRAME_X_NEED_BUFFER_FLIP (f) = false;
-
-  unblock_input ();
-}
-#endif
-
 /* Updates back buffer and flushes changes to display.  Called from
    minibuf read code.  Note that we display the back buffer even if
    buffer flipping is blocked.  */
@@ -6524,10 +6468,6 @@ x_flip_and_flush (struct frame *f)
     return;
 
   block_input ();
-#ifdef HAVE_XDBE
-  if (FRAME_X_NEED_BUFFER_FLIP (f))
-    show_back_buffer (f);
-#endif
   x_flush (f);
   unblock_input ();
 }
@@ -6542,7 +6482,7 @@ x_update_end (struct frame *f)
   MOUSE_HL_INFO (f)->mouse_face_defer = false;
 
 #ifdef USE_CAIRO
-  if (!FRAME_X_DOUBLE_BUFFERED_P (f) && FRAME_CR_CONTEXT (f))
+  if (FRAME_CR_CONTEXT (f))
     {
       block_input ();
       cairo_surface_flush (cairo_get_target (FRAME_CR_CONTEXT (f)));
@@ -6577,12 +6517,6 @@ XTframe_up_to_date (struct frame *f)
   block_input ();
   FRAME_MOUSE_UPDATE (f);
 
-#ifdef HAVE_XDBE
-  if (!buffer_flipping_blocked_p ()
-      && FRAME_X_NEED_BUFFER_FLIP (f))
-    show_back_buffer (f);
-#endif
-
 #ifdef HAVE_XSYNC
 #ifndef HAVE_GTK3
   if (FRAME_X_OUTPUT (f)->sync_end_pending_p
@@ -6634,15 +6568,6 @@ XTframe_up_to_date (struct frame *f)
   unblock_input ();
 }
 
-#ifdef HAVE_XDBE
-static void
-XTbuffer_flipping_unblocked_hook (struct frame *f)
-{
-  if (FRAME_X_NEED_BUFFER_FLIP (f))
-    show_back_buffer (f);
-}
-#endif
-
 /**
  * x_clear_under_internal_border:
  *
@@ -9966,11 +9891,7 @@ x_clear_area (struct frame *f, int x, int y, int width, int height)
   x_end_cr_clip (f);
 #else
 #ifndef USE_GTK
-  if (f->alpha_background != 1.0
-#ifdef HAVE_XDBE
-      || FRAME_X_DOUBLE_BUFFERED_P (f)
-#endif
-      )
+  if (f->alpha_background != 1.0)
 #endif
     {
 #if defined HAVE_XRENDER && \
@@ -14167,9 +14088,6 @@ x_scroll_bar_create (struct window *w, int top, int left,
     XSetWindowAttributes a;
     unsigned long mask;
     Window window;
-#ifdef HAVE_XDBE
-    Drawable drawable;
-#endif
 
     a.background_pixel = f->output_data.x->scroll_bar_background_pixel;
     if (a.background_pixel == -1)
@@ -14198,23 +14116,6 @@ x_scroll_bar_create (struct window *w, int top, int left,
 			    CopyFromParent,
 			     /* Attributes.  */
 			    mask, &a);
-#ifdef HAVE_XDBE
-    if (FRAME_DISPLAY_INFO (f)->supports_xdbe
-	&& FRAME_X_DOUBLE_BUFFERED_P (f))
-      {
-	x_catch_errors (FRAME_X_DISPLAY (f));
-	drawable = XdbeAllocateBackBufferName (FRAME_X_DISPLAY (f),
-					       window, XdbeCopied);
-	if (x_had_errors_p (FRAME_X_DISPLAY (f)))
-	  drawable = window;
-	else
-	  XSetWindowBackgroundPixmap (FRAME_X_DISPLAY (f), window, None);
-	x_uncatch_errors_after_check ();
-      }
-    else
-      drawable = window;
-#endif
-
 #ifdef HAVE_XINPUT2
   /* Ask for input extension button and motion events.  This lets us
      send the proper `wheel-up' or `wheel-down' events to Emacs.  */
@@ -14240,9 +14141,6 @@ x_scroll_bar_create (struct window *w, int top, int left,
 #endif
 
     bar->x_window = window;
-#ifdef HAVE_XDBE
-    bar->x_drawable = drawable;
-#endif
   }
 #endif /* not USE_TOOLKIT_SCROLL_BARS */
 
@@ -14316,11 +14214,7 @@ x_scroll_bar_set_handle (struct scroll_bar *bar, int start, int end,
 			 bool rebuild)
 {
   bool dragging = bar->dragging != -1;
-#ifndef HAVE_XDBE
   Window w = bar->x_window;
-#else
-  Drawable w = bar->x_drawable;
-#endif
   struct frame *f = XFRAME (WINDOW_FRAME (XWINDOW (bar->window)));
   GC gc = f->output_data.x->normal_gc;
 
@@ -14426,11 +14320,6 @@ x_scroll_bar_set_handle (struct scroll_bar *bar, int start, int end,
 		      FRAME_FOREGROUND_PIXEL (f));
   }
 
-#ifdef HAVE_XDBE
-  if (!rebuild)
-    x_scroll_bar_end_update (FRAME_DISPLAY_INFO (f), bar);
-#endif
-
   unblock_input ();
 }
 
@@ -14452,11 +14341,6 @@ x_scroll_bar_remove (struct scroll_bar *bar)
   XtDestroyWidget (SCROLL_BAR_X_WIDGET (FRAME_X_DISPLAY (f), bar));
 #endif /* not USE_GTK */
 #else
-#ifdef HAVE_XDBE
-  if (bar->x_window != bar->x_drawable)
-    XdbeDeallocateBackBufferName (FRAME_X_DISPLAY (f),
-				  bar->x_drawable);
-#endif
   XDestroyWindow (FRAME_X_DISPLAY (f), bar->x_window);
 #endif
 
@@ -14877,11 +14761,7 @@ XTjudge_scroll_bars (struct frame *f)
 static void
 x_scroll_bar_expose (struct scroll_bar *bar, const XEvent *event)
 {
-#ifndef HAVE_XDBE
   Window w = bar->x_window;
-#else
-  Drawable w = bar->x_drawable;
-#endif
   int x, y, width, height;
 
   if (event->type == Expose)
@@ -14904,25 +14784,6 @@ x_scroll_bar_expose (struct scroll_bar *bar, const XEvent *event)
 
   block_input ();
 
-#ifdef HAVE_XDBE
-  if (w != bar->x_window)
-    {
-      if (f->output_data.x->scroll_bar_background_pixel != -1)
-	XSetForeground (FRAME_X_DISPLAY (f), gc,
-			f->output_data.x->scroll_bar_background_pixel);
-      else
-	XSetForeground (FRAME_X_DISPLAY (f), gc,
-			FRAME_BACKGROUND_PIXEL (f));
-
-      XFillRectangle (FRAME_X_DISPLAY (f),
-		      bar->x_drawable,
-		      gc, x, y, width, height);
-
-      XSetForeground (FRAME_X_DISPLAY (f), gc,
-		      FRAME_FOREGROUND_PIXEL (f));
-    }
-#endif
-
   x_scroll_bar_set_handle (bar, bar->start, bar->end, true);
 
   /* Switch to scroll bar foreground color.  */
@@ -14946,10 +14807,6 @@ x_scroll_bar_expose (struct scroll_bar *bar, const XEvent *event)
     XSetForeground (FRAME_X_DISPLAY (f), gc,
 		    FRAME_FOREGROUND_PIXEL (f));
 
-#ifdef HAVE_XDBE
-  x_scroll_bar_end_update (FRAME_DISPLAY_INFO (f), bar);
-#endif
-
    unblock_input ();
 
 }
@@ -15091,24 +14948,6 @@ x_scroll_bar_note_movement (struct scroll_bar *bar,
     }
 }
 
-#ifdef HAVE_XDBE
-static void
-x_scroll_bar_end_update (struct x_display_info *dpyinfo,
-			 struct scroll_bar *bar)
-{
-  XdbeSwapInfo swap_info;
-
-  /* This means the scroll bar is double-buffered.  */
-  if (bar->x_drawable != bar->x_window)
-    {
-      memset (&swap_info, 0, sizeof swap_info);
-      swap_info.swap_window = bar->x_window;
-      swap_info.swap_action = XdbeCopied;
-      XdbeSwapBuffers (dpyinfo->display, &swap_info, 1);
-    }
-}
-#endif
-
 #endif /* !USE_TOOLKIT_SCROLL_BARS */
 
 /* Return information to the user about the current position of the mouse
@@ -15259,17 +15098,6 @@ x_scroll_bar_clear (struct frame *f)
 {
 #ifndef USE_TOOLKIT_SCROLL_BARS
   Lisp_Object bar;
-#ifdef HAVE_XDBE
-  GC gc = f->output_data.x->normal_gc;
-
-  if (f->output_data.x->scroll_bar_background_pixel != -1)
-    XSetForeground (FRAME_X_DISPLAY (f), gc,
-		    f->output_data.x->scroll_bar_background_pixel);
-  else
-    XSetForeground (FRAME_X_DISPLAY (f), gc,
-		    FRAME_BACKGROUND_PIXEL (f));
-#endif
-
   /* We can have scroll bars even if this is 0,
      if we just turned off scroll bar mode.
      But in that case we should not clear them.  */
@@ -15277,26 +15105,11 @@ x_scroll_bar_clear (struct frame *f)
     for (bar = FRAME_SCROLL_BARS (f); VECTORP (bar);
 	 bar = XSCROLL_BAR (bar)->next)
       {
-#ifdef HAVE_XDBE
-	if (XSCROLL_BAR (bar)->x_window
-	    == XSCROLL_BAR (bar)->x_drawable)
-#endif
 	  XClearArea (FRAME_X_DISPLAY (f),
 		      XSCROLL_BAR (bar)->x_window,
 		      0, 0, 0, 0, True);
-#ifdef HAVE_XDBE
-	else
-	  XFillRectangle (FRAME_X_DISPLAY (f),
-			  XSCROLL_BAR (bar)->x_drawable,
-			  gc, 0, 0, XSCROLL_BAR (bar)->width,
-			  XSCROLL_BAR (bar)->height);
-#endif
       }
 
-#ifdef HAVE_XDBE
-  XSetForeground (FRAME_X_DISPLAY (f), gc,
-		  FRAME_FOREGROUND_PIXEL (f));
-#endif
 #endif /* not USE_TOOLKIT_SCROLL_BARS */
 }
 
@@ -15531,19 +15344,6 @@ x_net_wm_state (struct frame *f, Window window)
 
 /* Flip back buffers on F if it has undrawn content.  */
 
-#ifdef HAVE_XDBE
-static void
-flush_dirty_back_buffer_on (struct frame *f)
-{
-  block_input ();
-  if (!FRAME_GARBAGED_P (f)
-      && !buffer_flipping_blocked_p ()
-      && FRAME_X_NEED_BUFFER_FLIP (f))
-    show_back_buffer (f);
-  unblock_input ();
-}
-#endif
-
 #ifdef HAVE_GTK3
 void
 x_scroll_bar_configure (GdkEvent *event)
@@ -17043,10 +16843,6 @@ handle_one_xevent (struct x_display_info *dpyinfo,
 		  SET_FRAME_ICONIFIED (f, false);
 		}
 
-#ifdef HAVE_XDBE
-	      if (FRAME_X_DOUBLE_BUFFERED_P (f))
-                x_drop_xrender_surfaces (f);
-#endif
               f->output_data.x->has_been_visible = true;
               SET_FRAME_GARBAGED (f);
               unblock_input ();
@@ -17091,10 +16887,6 @@ handle_one_xevent (struct x_display_info *dpyinfo,
 #endif
             }
 
-#ifdef HAVE_XDBE
-          if (!FRAME_GARBAGED_P (f))
-            show_back_buffer (f);
-#endif
         }
       else
         {
@@ -17141,9 +16933,6 @@ handle_one_xevent (struct x_display_info *dpyinfo,
                         event->xgraphicsexpose.height);
 #ifdef USE_GTK
 	  x_clear_under_internal_border (f);
-#endif
-#ifdef HAVE_XDBE
-	  show_back_buffer (f);
 #endif
         }
 #ifndef USE_TOOLKIT_SCROLL_BARS
@@ -18441,9 +18230,6 @@ handle_one_xevent (struct x_display_info *dpyinfo,
 		  x_flush (WINDOW_XFRAME (XWINDOW (bar->window)));
 		}
 
-	      if (f && FRAME_X_DOUBLE_BUFFERED_P (f))
-		x_drop_xrender_surfaces (f);
-
 	      goto OTHER;
 	    }
 #endif
@@ -18455,10 +18241,6 @@ handle_one_xevent (struct x_display_info *dpyinfo,
          for size changes: that's not sufficient.  We miss some
          surface invalidations and flicker.  */
       block_input ();
-#ifdef HAVE_XDBE
-      if (f && FRAME_X_DOUBLE_BUFFERED_P (f))
-        x_drop_xrender_surfaces (f);
-#endif
       unblock_input ();
 #if defined USE_CAIRO && !defined USE_GTK
       if (f)
@@ -18489,8 +18271,6 @@ handle_one_xevent (struct x_display_info *dpyinfo,
 	       f->new_width, f->new_height);
 
 	  block_input ();
-          if (FRAME_X_DOUBLE_BUFFERED_P (f))
-            x_drop_xrender_surfaces (f);
           unblock_input ();
           xg_frame_resized (f, configureEvent.xconfigure.width,
                             configureEvent.xconfigure.height);
@@ -22153,14 +21933,6 @@ handle_one_xevent (struct x_display_info *dpyinfo,
      redisplay.  To ensure that these changes become visible, draw
      them here.  */
 
-#ifdef HAVE_XDBE
-  if (f)
-    flush_dirty_back_buffer_on (f);
-
-  if (any && any != f)
-    flush_dirty_back_buffer_on (any);
-#endif
-
   SAFE_FREE ();
   return count;
 }
@@ -26491,14 +26263,6 @@ x_term_init (Lisp_Object display_name, char *xrm_option, char *resource_name)
 	}
     }
 
-#ifdef HAVE_XDBE
-  dpyinfo->supports_xdbe = false;
-  int xdbe_major;
-  int xdbe_minor;
-  if (XdbeQueryExtension (dpyinfo->display, &xdbe_major, &xdbe_minor))
-    dpyinfo->supports_xdbe = true;
-#endif
-
 #ifdef USE_XCB
   xcb_screen_t *xcb_screen = NULL;
   xcb_screen_iterator_t iter;
@@ -27276,9 +27040,6 @@ x_create_terminal (struct x_display_info *dpyinfo)
   terminal->update_end_hook = x_update_end;
   terminal->read_socket_hook = XTread_socket;
   terminal->frame_up_to_date_hook = XTframe_up_to_date;
-#ifdef HAVE_XDBE
-  terminal->buffer_flipping_unblocked_hook = XTbuffer_flipping_unblocked_hook;
-#endif
   terminal->defined_color_hook = x_defined_color;
   terminal->query_frame_background_color = x_query_frame_background_color;
   terminal->query_colors = x_query_colors;
diff --git a/src/xterm.h b/src/xterm.h
index 3d243f3eabf..1beb32c875e 100644
--- a/src/xterm.h
+++ b/src/xterm.h
@@ -653,10 +653,6 @@ struct x_display_info
   xcb_visualtype_t *xcb_visual;
 #endif
 
-#ifdef HAVE_XDBE
-  bool supports_xdbe;
-#endif
-
 #ifdef HAVE_XINPUT2
   bool supports_xi2;
   int xi2_version;
@@ -1090,14 +1086,6 @@ extern void x_mark_frame_dirty (struct frame *f);
 #define FRAME_X_DRAWABLE(f)                             \
   (x_mark_frame_dirty ((f)), FRAME_X_RAW_DRAWABLE ((f)))
 
-#ifdef HAVE_XDBE
-#define FRAME_X_DOUBLE_BUFFERED_P(f)            \
-  (FRAME_X_WINDOW (f) != FRAME_X_RAW_DRAWABLE (f))
-
-/* Return the need-buffer-flip flag for frame F.  */
-#define FRAME_X_NEED_BUFFER_FLIP(f) ((f)->output_data.x->need_buffer_flip)
-#endif
-
 /* Return the outermost X window associated with the frame F.  */
 #ifdef USE_X_TOOLKIT
 #define FRAME_OUTER_WINDOW(f) ((f)->output_data.x->widget ?             \
@@ -1220,11 +1208,6 @@ struct scroll_bar
   /* The X window representing this scroll bar.  */
   Window x_window;
 
-#if defined HAVE_XDBE && !defined USE_TOOLKIT_SCROLL_BARS
-  /* The X drawable representing this scroll bar.  */
-  Drawable x_drawable;
-#endif
-
   /* The position and size of the scroll bar in pixels, relative to the
      frame.  */
   int top, left, width, height;
