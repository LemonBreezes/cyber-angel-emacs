Debugger entered--Lisp error: (file-error "‘tramp_stat_directory_files_and_attributes /usr/share/drirc.d’ does not return a valid Lisp expression: ‘)\n’")
  signal(file-error ("‘tramp_stat_directory_files_and_attributes /usr/sh..."))
  tramp-error((tramp-file-name "sudo" "root" nil "ARUIZ-W10" nil "/usr/share/drirc.d" nil) file-error "‘tramp_stat_directory_files_and_attributes /usr/sh ...")
  tramp-signal-hook-function(file-error ("‘tramp_stat_directory_files_and_attributes /usr/sh..."))
  signal(file-error ("‘tramp_stat_directory_files_and_attributes /usr/sh..."))
  tramp-sh-handle-directory-files-and-attributes("/sudo:root@ARUIZ-W10:/usr/share/drirc.d" nil "\\`[^.]" t string nil)
  tramp-sh-file-name-handler(directory-files-and-attributes "/sudo:root@ARUIZ-W10:/usr/share/drirc.d" nil "\\`[^.]" t string nil)
  apply(tramp-sh-file-name-handler directory-files-and-attributes ("/sudo:root@ARUIZ-W10:/usr/share/drirc.d" nil "\\`[^.]" t string nil))
  tramp-file-name-handler(directory-files-and-attributes "/sudo:root@ARUIZ-W10:/usr/share/drirc.d" nil "\\`[^.]" t string nil)
  eshell-directory-files-and-attributes("." nil "\\`[^.]" t string)
  eshell-ls-dir(("." t 2 "root" "root" (25601 11672 0 0) (25595 54728 0 0) (25595 54728 0 0) 4096 "drwxr-xr-x" nil 598468 (-1 . 1)) nil #("/sudo:root@ARUIZ-W10:/usr/share/drirc.d/" 6 10 (tramp-default t) 11 20 (tramp-default t)) 0)
  eshell-ls-entries((("." t 2 "root" "root" (25601 11672 0 0) (25595 54728 0 0) (25595 54728 0 0) 4096 "drwxr-xr-x" nil 598468 (-1 . 1))) t #("/sudo:root@ARUIZ-W10:/usr/share/drirc.d/" 6 10 (tramp-default t) 11 20 (tramp-default t)))
  eshell-do-ls()
  apply(eshell-do-ls nil)
  eshell/ls()
  apply(eshell/ls nil)
  eshell-exec-lisp(eshell-print eshell-error eshell/ls nil nil)
  eshell-lisp-command(eshell/ls nil)
  eshell-plain-command("ls" nil)
  eshell-named-command("ls")
  eval((eshell-named-command '"ls"))
  eshell-do-eval((eshell-named-command '"ls") nil)
  eshell-do-eval((prog1 (eshell-named-command '"ls") (mapc #'funcall eshell-this-command-hook)) nil)
  (condition-case err (eshell-do-eval '(prog1 (eshell-named-command '"ls") (mapc #'funcall eshell-this-command-hook)) nil) ((debug error) (mapc #'funcall eshell-this-command-hook) (eshell-errorn (error-message-string err)) (eshell-close-handles 1)))
  eval((condition-case err (eshell-do-eval '(prog1 (eshell-named-command '"ls") (mapc #'funcall eshell-this-command-hook)) nil) ((debug error) (mapc #'funcall eshell-this-command-hook) (eshell-errorn (error-message-string err)) (eshell-close-handles 1))))
  eshell-do-eval((condition-case err (eshell-do-eval '(prog1 (eshell-named-command '"ls") (mapc #'funcall eshell-this-command-hook)) nil) ((debug error) (mapc #'funcall eshell-this-command-hook) (eshell-errorn (error-message-string err)) (eshell-close-handles 1))) nil)
  #f(compiled-function () #<bytecode 0x1c628c79df779479>)()
  funcall(#f(compiled-function () #<bytecode 0x1c628c79df779479>))
  (let ((eshell-this-command-hook '(ignore))) (funcall '#f(compiled-function () #<bytecode 0x1c628c79df779479>)))
  eval((let ((eshell-this-command-hook '(ignore))) (funcall '#f(compiled-function () #<bytecode 0x1c628c79df779479>))))
  eshell-do-eval((let ((eshell-this-command-hook '(ignore))) (condition-case err (eshell-do-eval '(prog1 (eshell-named-command '"ls") (mapc #'funcall eshell-this-command-hook)) nil) ((debug error) (mapc #'funcall eshell-this-command-hook) (eshell-errorn (error-message-string err)) (eshell-close-handles 1)))) nil)
  #f(compiled-function () #<bytecode 0x1c628c79df779479>)()
  funcall(#f(compiled-function () #<bytecode 0x1c628c79df779479>))
  (let ((eshell-current-handles '[nil (((t) . 2) t) (((t) . 2) t)])) (funcall '#f(compiled-function () #<bytecode 0x1c628c79df779479>)))
  eval((let ((eshell-current-handles '[nil ((... . 2) t) ((... . 2) t)])) (funcall '#f(compiled-function () #<bytecode 0x1c628c79df779479>))))
  eshell-do-eval((let ((eshell-current-handles '[nil ((... . 2) t) ((... . 2) t)])) (let ((eshell-this-command-hook '(ignore))) (condition-case err (eshell-do-eval '(prog1 (eshell-named-command ...) (mapc ... eshell-this-command-hook)) nil) ((debug error) (mapc #'funcall eshell-this-command-hook) (eshell-errorn (error-message-string err)) (eshell-close-handles 1))))) nil)
  eshell-do-eval((progn (let ((eshell-current-handles '[nil (... t) (... t)])) (let ((eshell-this-command-hook '(ignore))) (condition-case err (eshell-do-eval '(prog1 ... ...) nil) ((debug error) (mapc #'funcall eshell-this-command-hook) (eshell-errorn (error-message-string err)) (eshell-close-handles 1)))))) nil)
  (catch 'top-level (eshell-do-eval '(progn (let ((eshell-current-handles '...)) (let ((eshell-this-command-hook ...)) (condition-case err (eshell-do-eval ... nil) (... ... ... ...))))) nil))
  eval((catch 'top-level (eshell-do-eval '(progn (let ((eshell-current-handles ...)) (let (...) (condition-case err ... ...)))) nil)))
  eshell-do-eval((catch 'top-level (eshell-do-eval '(progn (let ((eshell-current-handles ...)) (let (...) (condition-case err ... ...)))) nil)) nil)
  eshell-do-eval((progn 'nil (catch 'top-level (eshell-do-eval '(progn (let (...) (let ... ...))) nil)) (run-hooks 'eshell-post-command-hook)) nil)
  #f(compiled-function () #<bytecode 0x1c628c79df779479>)()
  funcall(#f(compiled-function () #<bytecode 0x1c628c79df779479>))
  (let ((eshell-current-handles '[nil (((t) . 2) t) (((t) . 2) t)]) (eshell-current-subjob-p 'nil)) (funcall '#f(compiled-function () #<bytecode 0x1c628c79df779479>)))
  eval((let ((eshell-current-handles '[nil ((... . 2) t) ((... . 2) t)]) (eshell-current-subjob-p 'nil)) (funcall '#f(compiled-function () #<bytecode 0x1c628c79df779479>))))
  eshell-do-eval((let ((eshell-current-handles '[nil ((... . 2) t) ((... . 2) t)]) eshell-current-subjob-p) (progn 'nil (catch 'top-level (eshell-do-eval '(progn (let ... ...)) nil)) (run-hooks 'eshell-post-command-hook))))
  eshell-resume-eval()
  eshell-eval-command((let ((eshell-current-handles '[nil ((... . 2) t) ((... . 2) t)]) eshell-current-subjob-p) (progn 'nil (catch 'top-level (eshell-do-eval '(progn (let ... ...)) nil)) (run-hooks 'eshell-post-command-hook))) "ls")
  #<subr eshell-send-input>()
  apply(#<subr eshell-send-input> nil)
  eshell-send-input()
  funcall-interactively(eshell-send-input)
  command-execute(eshell-send-input)


